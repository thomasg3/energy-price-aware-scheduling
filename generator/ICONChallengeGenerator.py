#!/usr/bin/env python
# Instance generator for the ICON Challenge, 2014
#
# Energy-Cost Aware Scheduling/Forecasting Competition
# H. Simonis, B. O'Sullivan, D. Metha, B. Hurley, M. De Cauwer
#
# The file format is straight forward and described in the above document. Tasks
# are generated by partitioning the resource capacity across the day into
# rectangles. Each rectangle then represents a task and its resource use over
# time. Resource use for the tasks is shrunk slightly according to the beta and
# kappa parameters to add slack. Some tasks are then deleted to match the target
# number of tasks parameter. Energy price data is not taken into account in the
# task generation. Power usage is calculated based on a function of the resource
# consumption.
#
# This method guarantees a satisfiable instance and allows fine grained control
# of the slack. The generator will also output a 'solution.txt' which is the
# initial assignment during generation, this is not an optimal solution.
#
# ==============================================================================
# Sketch of data format in the form:
# param (default value) - Description
#
# Time_Resolution (5) - Number of divisions within an hour
# Nr_of_Resources (3) - Number of resources (CPU, RAM, IO, etc)
#
# Nr_of_Machines (> 20)
# Machine[k 1..Nr_of_Machines] idle up down
# Resource_1 Resource_2 ... Resource_n
#
# Nr_of_Tasks (> 2000)
#
# Task[j Nr_of_Tasks] Duration earliest_start lastest_end power
# Resource_1, Resource_2 ... Resource_n
#
# ==============================================================================

#python ICONChallengeGenerator.py -m 1 -t 50 -s 45 -r 2 -c 10 -b 2.0 -k 2.0

import os
import random
import argparse
import math
import rectangle as geo
import numpy as np


MINUTESINDAY = 24 * 60
INSTANCEBASENAME = "instance.txt"
SOLUTIONBASENAME = "solution.txt"


class Instance(object):

    def __init__(self, args):
        self.machines = []
        self.tasks = []
        self.q = args.Time_Resolution
        self.nResources = args.Nr_of_Resources
        self.nTask = args.Nr_of_Tasks
        self.cTask = 0
        self.nMachine = args.Nr_of_Machines
        self.nTaskPerMachine = int(math.ceil(float(self.nTask) / float(self.nMachine)))
        self.lOrigPacking = []
        self.periods = int(MINUTESINDAY / args.Time_Resolution)

        # Creating machines
        for m in range(self.nMachine):
            self.machines.append(Machine(m, self.getMachineClass(), args))

        # Creating tasks
        for m in range(self.nMachine):
            # Creating an original packing per machine
            oPacking = Packing(args, self.nTaskPerMachine, mac=m)
            oPacking.populate()

            self.lOrigPacking.append(oPacking)

            for idx in range(len(oPacking.boxes)):
                b = oPacking.boxes[idx]
                t = Task(self.cTask, abs(b.right - b.left), b.left, b.right, b.top, self.machines[m], abs(b.top - b.bottom), args)
                self.tasks.append(t)
                self.cTask += 1

        for r in range(self.nResources):
            self.cTask = 0
            for m in range(self.nMachine):
                # Create the partions for all extra dimension of the problem
                p = self.lOrigPacking[m].copy(r)
                p.transformYScale()
                #p.plotPacking(name = "machine{1}_resource{0}.png".format(r, m))
                self.machines[m].resources[r] = p.maxy
                for idx in range(len(p.boxes)):
                    b = p.boxes[idx]
                    self.tasks[self.cTask].requirements.append(abs(b.top - b.bottom))
                    self.cTask += 1

        for t in self.tasks:
            t.setDurations(args.beta)
            t.setRequirements(args.kappa)

        for m in self.machines:
            m.computeAlpha()

        self.meanAlpha = np.mean([x.alpha for x in self.machines])

        for t in self.tasks:
            t.setPowerConsumption(args.gamma, self.meanAlpha)
            t.setEarliestStartingTime(args.nu)
            t.setLatestEndingTime(args.nu, self.periods)

        if len(self.tasks) - args.Nr_of_Tasks > 0:
            self.deleteNTasks(len(self.tasks) - args.Nr_of_Tasks)

        self.reIndexTasks()

    def reIndexTasks(self):
        idx = random.sample(range(0, len(self.tasks)), len(self.tasks))
        for i, t in enumerate(self.tasks):
            t.taskid = idx[i]

    def deleteNTasks(self, n):
        ts = random.sample(self.tasks, n)
        for t in ts:
            self.tasks.remove(t)
        # ReIndex the tasks

    def printInstance(self, filename):
        with open(filename, "wt") as f:

            print >> f, str(self.q)
            print >> f, str(self.nResources)

            print >> f, len(self.machines)
            for m in self.machines:
                m.printMachine(f)
            print >> f, len(self.tasks)
            for t in sorted(self.tasks, key=lambda task: task.taskid):
                t.printTask(f)

        # Dump the generated solution for testing purposes
        solfilename = os.path.join(os.path.dirname(filename), SOLUTIONBASENAME)
        with open(solfilename, "wt") as f:
            print >> f, len(self.machines)
            for m in self.machines:
                print >> f, m.machineid
                print >> f, 2  # Simple two events, on at start, off at end
                print >> f, 1, 0
                print >> f, 0, self.periods - 1

            print >> f, len(self.tasks)
            for t in sorted(self.tasks, key=lambda task: task.taskid):
                print >> f, t.taskid, t.belongsto.machineid, max(t.est, t.oEst)

    def getMachineClass(self):
        # Todo : Think about the relationship between Idle cost and up + down costs.
        classA = {'idle': 150, 'up': 0.10, 'down': 0.05}
        classB = {'idle': 120, 'up': 0.07, 'down': 0.15}
        classC = {'idle': 130, 'up': 0.03, 'down': 0.07}
        classD = {'idle': 170, 'up': 0.15, 'down': 0.07}
        classE = {'idle': 190, 'up': 0.05, 'down': 0.03}
        classes = [classA, classB, classC, classD, classE]

        return random.sample(classes, 1)[0]

    def plot(self):
        import matplotlib.pyplot as plt
        maxy = 1200
        miny = -1
        maxx = 288
        minx = -1

        plt.figure(figsize=(13, 9))
        plt.axis([minx, maxx, miny, maxy])

        for idx, t in enumerate(self.tasks):

            plt.hlines(y=t.oBottom, xmin=t.est, xmax=t.let, linewidth=1, color='black')

            # The new space
            oB = plt.Rectangle(((t.est + (t.let - t.est)/2 - t.duration / 2), t.oBottom), (t.duration), abs(t.requirements[0]), facecolor='blue', edgecolor='black')
            plt.gca().add_patch(oB)

            # The original sapce
            nB = plt.Rectangle(((t.oLet + (t.oLet - t.oEst)/2 - t.oDuration / 2), t.oBottom), (t.duration), abs(t.oBottom - t.oReq), facecolor='red', edgecolor='black')
            plt.gca().add_patch(nB)

        plt.show()
        #plt.savefig(name, bbox_inches='tight', dpi = 200)


class Task(object):

    def __init__(self, taskid,  duration, est, let, oBottom, belongsto, req, args):
        self.taskid = taskid
        self.duration = duration
        self.oDuration = duration
        self.est = est
        self.oEst = est
        self.let = let
        self.oLet = let
        self.oBottom = oBottom
        self.powUsage = 0.0
        self.requirements = []
        self.belongsto = belongsto
        self.oReq = req
        self.args = args

    def printTask(self, f):
        print >> f, "%d %d %d %d %.2f" % (self.taskid, self.duration, self.est, self.let, self.powUsage)
        print >> f, " ".join(map(str, self.requirements))

    def __str__(self):
        return "Task ID {0} - Duration {1} in window [{2}-{3}] requiring {4} consuming {5}".format(self.taskid, self.duration, self.est, self.let, self.requirements, self.powUsage)

    #def setPowerConsumption(self, gamma):
        ## Power is a non linear function of the resource consumption

        #for r in range(len(self.requirements)):
            ##print self.args.yOrig
            #self.powUsage += ((self.requirements[r] / float(self.belongsto.resources[r])) ** 2 ) * 100

            ##print r, self.requirements[r]

        #self.powUsage = self.powUsage / len(self.requirements)
        #self.powUsage = max(0.1, self.powUsage)

    def setPowerConsumption(self, gamma, meanAlpha):
        self.powUsage = meanAlpha * sum([self.belongsto.beta[r] * self.requirements[r] for r in range(len(self.requirements))])

    def setEarliestStartingTime(self, nu):

        self.est = max(random.randint(0, self.let - self.duration), 0)

    def setLatestEndingTime(self, nu, late):
        self.let = min(random.randint(self.let, late), late)

    def setDurations(self, beta):
        self.duration = int(math.ceil(random.uniform(beta, 1) * self.duration))

    def setRequirements(self, kappa):
        # shrinking the requirements for tasks. Done in every dimension
        for d in range(len(self.requirements)):
            self.requirements[d] = int(math.ceil(random.uniform(kappa, 1.0) * self.requirements[d]))


class Machine(object):
    def __init__(self, machineid, mClass, args):
        self.machineid = machineid
        self.nrresources = args.Nr_of_Resources

        self.idle = mClass['idle']
        self.up = mClass['up']
        self.down = mClass['down']

        self.resources = [0.0] * self.nrresources

        self.beta = [0.7, 0.15, 0.1, 0.05]

        self.alpha = 0

    def printMachine(self, f):
        print >> f, "%d %d %.1f %.1f" % (self.machineid, self.idle, self.up, self.down)
        print >> f, " ".join(map(str, self.resources))

    def computeAlpha(self):
        self.alpha = 1000 / (sum([self.beta[i] * self.resources[i] for i in range(self.nrresources)]))


class Packing(object):

    def __init__(self, args, nTaskPerMachine, boxes=[], iRes=None, mac=None):
        self.args = args
        self.iRes = iRes
        self.maxx = (MINUTESINDAY / args.Time_Resolution) - 1
        self.maxy = 0.0
        self.nTaskPerMachine = nTaskPerMachine
        self.boxes = boxes
        self.numOfSplits = int(math.ceil(float(nTaskPerMachine - 1) / float(3)))
        self.mac = mac

    def copy(self, iRes):
        return Packing(self.args, self.nTaskPerMachine, self.boxes, iRes, self.mac)

    def populate(self):
        # Populates the packing
        self.boxes = [geo.Rect(geo.Point(0, 0), geo.Point(self.maxx, self.args.yOrig))]
        i = 0
        while i < self.numOfSplits:
            # Spliting strat on the boxes
            if self.args.splitStrategy == "box":
                # Getting the candidate Boxes to split
                self.candidateBoxes = [x for x in self.boxes if abs(x.right - x.left) > self.args.epsilon and abs(x.bottom - x.top) > self.args.epsilon]

                # Pick a random retangle in the list of boxes
                self.rB = random.sample(self.candidateBoxes, 1)[0]

                # Getting a point in that box
                self.rP = geo.Point(x=random.randint(r.left + 1, r.right - 1), y=random.randint(r.top + 1, r.bottom - 1))

                # Spliting on the point
                self.boxes += self.split(self.rP, self.rB, i)

                # Remove r from the list
                self.boxes.remove(self.rB)

            elif self.args.splitStrategy == "point" :
                # Spliting strat on the random points from the original space

                # Pick a random point
                self.rP = geo.Point(x=random.randint(0 + 1, self.maxx - 1), y=random.randint(0 + 1, self.args.yOrig - 1))

                # Find box to which this point belongs to
                self.cBox = self.findIncludingBox(self.rP)

                # Split the box
                newboxes = self.split(self.rP, self.cBox, i)

                # Check for zero sized boxes:
                def validboxes(testboxes):
                    for b in newboxes:
                        if b.left == b.right or b.top == b.bottom:
                            return False
                    return True

                if validboxes(newboxes):
                    self.boxes += newboxes
                    self.boxes.remove(self.cBox)  # Remove r from the list
                else:
                    i -= 1

            i += 1

        self.maxy = max([x.bottom for x in self.boxes])
        self.miny = min([x.top for x in self.boxes])
        self.maxx = max([x.right for x in self.boxes])
        self.minx = min([x.left for x in self.boxes])

    def split(self, splitPoint, box, i):
        # Create four rectangle from this point and add to the list
        tR1 = geo.Rect(geo.Point(splitPoint.x, box.top_left().y), geo.Point(box.top_left().x, splitPoint.y), data=i)
        tR2 = geo.Rect(splitPoint, box.top_right(), data=i)
        tR3 = geo.Rect(box.bottom_left(), splitPoint, data=i)
        tR4 = geo.Rect(geo.Point(splitPoint.x, box.bottom_right().y), geo.Point(box.bottom_right().x, splitPoint.y), data=i)
        return [tR1, tR2, tR3, tR4]

    def findIncludingBox(self, p):
        for b in self.boxes:
            if b.contains(p):
                self.cBox = b
                break
        return self.cBox

    def transformYScale(self):
        # Homebrewed transformation of the y scale
        self.scaledTasks = []

        # we need a factor per unit on the y axis
        self.factors = [1 for i in range(self.args.yOrig)]

        #TODO : Could be any distribution here
        self.k = range(int(self.args.yOrig / self.args.Nr_of_Resources) * (self.iRes), int(self.args.yOrig / self.args.Nr_of_Resources) * (self.iRes + 1))
        #print "{0}".format(self.k)

        for i in self.k:
            self.factors[i] = random.randint(self.args.minScaling, self.args.maxScaling)
        #print "{0}".format(self.factors)

        for b in self.boxes:
            self.allBot = sum([self.factors[x] for x in range(b.top)])

            self.newBotLeft  = geo.Point(b.left, self.allBot)
            self.allIn = sum([self.factors[x] for x in range(b.top, b.bottom)])
            self.newTopRight = geo.Point(b.right, self.allBot + self.allIn)
            self.scaledTask = geo.Rect(self.newBotLeft, self.newTopRight)
            self.scaledTask.data = b.data
            self.scaledTasks.append(self.scaledTask)

        self.boxes = self.scaledTasks

        self.maxy = max([x.bottom for x in self.boxes])
        self.miny = min([x.top for x in self.boxes])
        self.maxx = max([x.right for x in self.boxes])
        self.minx = min([x.left for x in self.boxes])

    def plotPacking(self, name):
        import matplotlib.pyplot as plt
        plt.plot()

        plt.axis([self.minx, self.maxx, self.miny, self.maxy])
        self.colours = [
            "#996600", "#CC9900", "#FFCC00", "#FFFF00", "#FFFF99", "#FFDB9D",
            "#FFCC66", "#FF9933", "#FF794B", "#FF3300", "#990000", "#333366",
            "#003399", "#0066CC", "#0083D7", "#0099FF", "#3E9ADE", "#99CCFF",
            "#B4E2FF", "#DEFFFF", "#FFCCFF", "#CCCCFF", "#9999FF", "#6666CC",
            "#9999CC", "#666699", "#006600", "#009900", "#66CC33", "#99FF66",
            "#CCFFCC"
        ]
        self.colours = 20 * self.colours

        for r in self.boxes:

            rect = plt.Rectangle((r.left, r.top), (r.right - r.left), (r.bottom - r.top), facecolor=self.colours[r.data], edgecolor='black')
            plt.gca().add_patch(rect)
        #plt.show()
        plt.savefig(name, bbox_inches='tight', dpi=200)


def main():
    parser = argparse.ArgumentParser(description="Instance generator for the ICON 2014 competition")
    parser.add_argument("-s", "--seed", action="store", default=42, nargs='?', type=int, help="Seed")
    parser.add_argument("-m", "--Nr_of_Machines", action="store", default=20, nargs='?', type=int, help="Number of Machines")
    parser.add_argument("-r", "--Nr_of_Resources", action="store", default=3, nargs='?', type=int, help="Number of Resources")
    parser.add_argument("-t", "--Nr_of_Tasks", action="store", default=50, nargs='?', type=int, help="Number of Tasks")
    parser.add_argument("-q", "--Time_Resolution", action="store", default=5, nargs='?', type=int, help="Time Resolution")
    parser.add_argument("-i", "--instance", action="store", default="./instances", nargs='?', type=str, help="Path to the folder where the instance should be stored.")
    parser.add_argument("-e", "--epsilon", action="store", default=3, nargs='?', type=int, help="size of box beyond one shall not split")
    parser.add_argument("-a", "--splitStrategy", action="store", default="point", nargs='?', type=str, help="box or point")
    parser.add_argument("-c", "--maxScaling", action="store", default=10, nargs='?', type=int, help="maxScaling factor")
    parser.add_argument("-d", "--minScaling", action="store", default=1, nargs='?', type=int, help="minScaling factor")
    parser.add_argument("-y", "--yOrig", action="store", default=1000, nargs='?', type=int, help="Original max Y")
    parser.add_argument("-g", "--gamma", action="store", default=2.0, nargs='?', type=float, help="Gamma")
    parser.add_argument("-b", "--beta", action="store", default=0.5, nargs='?', type=float, help="Controling the time slack")
    parser.add_argument("-k", "--kappa", action="store", default=0.5, nargs='?', type=float, help="Controling the ressource slack")
    parser.add_argument("-n", "--nu", action="store", default=1.0, nargs='?', type=float, help="Controling the est and tet (not implemented)")

    args = parser.parse_args()
    random.seed(args.seed)

    instance = Instance(args)
    #instance.plot()

    ## Printing the instance
    folder = os.path.abspath(args.instance)
    if not os.path.isdir(folder):
        os.makedirs(folder)
    fname = "instance_t{0}_m{1}_r{2}_s{3}_b{4}_k{5}.txt".format(
        args.Nr_of_Tasks, args.Nr_of_Machines, args.Nr_of_Resources,
        args.seed, args.beta, args.kappa)

    #filename = os.path.join(folder, INSTANCEBASENAME)
    filename = os.path.join(folder, fname)
    instance.printInstance(filename)


if __name__ == '__main__':
    main()
